package models

import 	"database/sql"
import	"github.com/herb-go/herb/model/sql/querybuilder"

//{{.Name.Pascal}}Model :{{.Name.Raw }} model 
type {{.Name.Pascal}}Model struct{
    {{.Name.Pascal}}ModelFields
}

//BeforeInsert event called before mapper insert.
//You should call this event before your own insert query.
 func (m *{{.Name.Pascal}}Model) BeforeInsert() error {
 	return nil
 }

//AfterInsert event called after mapper insert.
//You should call this event before your own insert query.
 func (m *{{.Name.Pascal}}Model) AfterInsert() error {
 	return nil
 }

//BeforeUpdate event called before mapper update.
//You should call this event before your own update query.
 func (m *{{.Name.Pascal}}Model) BeforeUpdate() error {
 	return nil
 }

//AfterUpdate event called after mapper update.
//You should call this event after your own update query.
 func (m *{{.Name.Pascal}}Model) AfterUpdate() error {
 	return nil
 }

//AfterFind event called after mapper find.
//You should call this event after your own find query.
 func (m *{{.Name.Pascal}}Model) AfterFind() error {
 	return nil
 }

//AfterDelete event called after mapper delete.
//You should call this event after your own delete query.
 func (m *{{.Name.Pascal}}Model) AfterDelete() error {
 	return nil
 }

//New{{.Name.Pascal}}Model create new {{.Name.Pascal}}Model
func New{{.Name.Pascal}}Model() *{{.Name.Pascal}}Model{
	model:=&{{.Name.Pascal}}Model{
        //put your own model init code here
    }
    return model
}


type {{.Name.Pascal}}ModelResult struct {
	Model  *{{.Name.Pascal}}Model
	fields []string
}

func (r *{{.Name.Pascal}}ModelResult) Fields() *querybuilder.Fields {
	return r.Model.BuildFields(true, r.fields...)
}

func (r *{{.Name.Pascal}}ModelResult) OnFinish(err error) error {
	if err == sql.ErrNoRows {
		r.Model = nil
		return nil
	}
	if err != nil {
		return err
	}
	return r.Model.AfterFind()
}

func New{{.Name.Pascal}}ModelResult(fields ...string) *{{.Name.Pascal}}ModelResult {
	if len(fields) == 0 {
		fields = Default{{.Name.Pascal}}FieldsSelect
	}
	return &{{.Name.Pascal}}ModelResult{
		Model:  New{{.Name.Pascal}}Model(),
		fields: fields,
	}
}

type {{.Name.Pascal}}ModelsResult struct {
	Models []*{{.Name.Pascal}}Model
	fields []string
}

func (r *{{.Name.Pascal}}ModelsResult) Fields() *querybuilder.Fields {
	model := New{{.Name.Pascal}}Model()
	r.Models = append(r.Models, model)
	return model.BuildFields(true, r.fields...)
}

func (r *{{.Name.Pascal}}ModelsResult) OnFinish(err error) error {
	if err != nil {
		return err
	}
	model := r.Models[len(r.Models)-1]
	return model.AfterFind()
}

func New{{.Name.Pascal}}ModelsResult(fields ...string) *{{.Name.Pascal}}ModelsResult {
	if len(fields) == 0 {
		fields = Default{{.Name.Pascal}}FieldsSelect
	}
	return &{{.Name.Pascal}}ModelsResult{
		Models: []*{{.Name.Pascal}}Model{},
		fields: fields,
	}
}