package models

import (
	"database/sql"
	database "modules/{{.Columns.Database}}"
    "modules/{{.Module}}"
	{{if .Columns.HasTime}}"time"
    {{end -}}

	"github.com/herb-go/herb/model/sql/db"
	"github.com/herb-go/herb/model/sql/querybuilder"
	"github.com/herb-go/herb/model/sql/querybuilder/modelmapper"
	"github.com/herb-go/util"
)

{{$Name := .Name}}

//{{$Name.Pascal}}TableName table name of model  {{.Name.Raw}}
const {{$Name.Pascal}}TableName= "{{.Name.Raw}}"

//{{$Name.Pascal}}TableAlias table alias of model  {{.Name.Raw}} which will not changed when table name changed.
const {{$Name.Pascal}}TableAlias="{{.Name.Raw}}"

//{{.Name.Pascal}}Mapper : table {{.Name.Raw}}  mapper struct
type {{.Name.Pascal}}Mapper struct{
   	*modelmapper.ModelMapper
}

//InsertModelWithoutEvent build insert task and bind model for table {{.Name.Raw}} .
//Event BeforeInsert will not be called.
func (mapper *{{.Name.Pascal}}Mapper) InsertModelWithoutEvent(model *{{.Name.Pascal}}Model,fields ...string) *modelmapper.InsertTask{
	Insert:=mapper.Insert()
	if len(fields)==0{
		fields=Default{{.Name.Pascal}}FieldsInsert
	}
	Insert.Insert.Insert.AddFields(model.BuildFields(false,fields...))
    return Insert
}

//InsertModel : build insert task and bind model for table {{.Name.Raw}} 
func (mapper *{{.Name.Pascal}}Mapper) InsertModel(model *{{.Name.Pascal}}Model,fields ...string) *modelmapper.InsertTask{
	t:=mapper.InsertModelWithoutEvent(model,fields...)
	t.OnPrepare(model.BeforeInsert)
	t.OnSuccess(model.AfterInsert)
	return t
}

//UpdateModelWithPrimaryKey : build update query and bind model for table {{.Name.Raw}}  with given primary 
func (mapper *{{.Name.Pascal}}Mapper) UpdateModelWithPrimaryKey(pk {{.Columns.PrimayKeyField}} ,model *{{.Name.Pascal}}Model,fields ...string) *modelmapper.UpdateTask{
	Update:=mapper.UpdateModelWithoutPrimaryKey(model,fields...)
	Update.Where.Condition=mapper.BuildByPKQuery(pk)
	return Update
}

//UpdateModelWithoutPrimaryKey  build update query and bind model for table {{.Name.Raw}} 
func (mapper *{{.Name.Pascal}}Mapper)UpdateModelWithoutPrimaryKey(model *{{.Name.Pascal}}Model,fields ...string) *modelmapper.UpdateTask{
	u:=mapper.UpdateModelWithoutPrimaryKeyAndEvent(model,fields...)
	u.OnPrepare(model.BeforeUpdate)
	u.OnSuccess(model.AfterUpdate)
	return u
}

//UpdateModelWithoutPrimaryKeyAndEvent  build update query and bind model for table {{.Name.Raw}}.
//Event BeforeUpdate will not be called.
func (mapper *{{.Name.Pascal}}Mapper) UpdateModelWithoutPrimaryKeyAndEvent(model *{{.Name.Pascal}}Model,fields ...string) *modelmapper.UpdateTask{
	Update:=mapper.Update()
	if len(fields)==0{
		fields=Default{{.Name.Pascal}}FieldsUpdate
	}
	Update.Update.Update.AddFields(model.BuildFields(false,fields...))
	return Update
}



//DeleteByPrimaryKey : build delete query for table {{.Name.Raw}} with given primary key. 
func (mapper *{{.Name.Pascal}}Mapper) DeleteByPrimaryKey(pk {{.Columns.PrimayKeyField}}) *modelmapper.DeleteTask{
	Delete:=mapper.Delete()
	Delete.Where.Condition = mapper.BuildByPKQuery(pk)
	return Delete
}

//DeleteModelByPrimayKey : delete {{.Name.Raw}}  model in database;
//func (mapper *{{.Name.Pascal}}Mapper) DeleteModelByPrimayKey(pk {{.Columns.PrimayKeyField}}) (sql.Result,error){
//	model, err := mapper.FindByPrimaryKey(pk)
//	if err != nil {
//		return nil, err
//	}
//	Delete := mapper.DeleteByPrimaryKey(pk)
//	Delete.OnSuccess(model.AfterDelete)
//	return Delete.Exec()
//}


//SelectModel : build select query and bind model for table {{.Name.Raw}} 
func (mapper *{{.Name.Pascal}}Mapper) SelectModel(fields ...string) *modelmapper.SelectTask{
	Select:=mapper.NewSelect()
	model:=New{{.Name.Pascal}}Model()
	if len(fields)==0{
		fields=Default{{.Name.Pascal}}FieldsSelect
	}
	Select.Select.AddFields(model.BuildFields(true,fields...))
	return modelmapper.NewSelectTask(Select,mapper)
}


//Find : find {{.Name.Pascal}}Model from table {{.Name.Raw}} by given select query.
//func (mapper *{{.Name.Pascal}}Mapper) Find(Select *querybuilder.Select,fields ...string) (*{{.Name.Pascal}}Model,error){
//   model:=New{{.Name.Pascal}}Model()
//	row := Select.QueryRow(mapper)
//	if len(fields)==0{
//		fields=Default{{.Name.Pascal}}FieldsSelect
//	}
//	err := Select.Result().
//		BindFields(model.BuildFields(true,fields...)).
//		ScanFrom(row)
//	if err == sql.ErrNoRows {
//		return nil, nil
//	}
//	if err != nil {
//		return nil, err
//	}
//	return model, model.AfterFind()
//}

//SelectModelByPrimaryKey find {{.Name.Pascal}}Model from table {{.Name.Raw}} by primary key.
func (mapper *{{.Name.Pascal}}Mapper) SelectModelByPrimaryKey(pk {{.Columns.PrimayKeyField}},fields ...string) *modelmapper.SelectTask {
    Select:=mapper.SelectModel()
	Select.Where.Condition = mapper.BuildByPKQuery(pk)
	return Select
}

//SelectModelByField find {{.Name.Pascal}}Model from table {{.Name.Raw}} by given field name and field value.
func (mapper *{{.Name.Pascal}}Mapper)  SelectModelByField(fieldName string, fieldValue interface{},fields ...string) *modelmapper.SelectTask{
    Select:=mapper.SelectModel()
	Select.Where.Condition = mapper.QueryBuilder().Equal(fieldName, fieldValue)
	return Select
}

//SelectModelByFields : find {{.Name.Pascal}}Model from table {{.Name.Raw}} by given field name and field value map.
func (mapper *{{.Name.Pascal}}Mapper) SelectModelByFields(fieldsmap map[string]interface{},fields ...string) *modelmapper.SelectTask{
    Select:=mapper.SelectModel()
    for k,v:=range fieldsmap{
	    Select.Where.Condition.And(mapper.QueryBuilder().Equal(k, v))
    }
	return Select
}

//FindAll : find all {{.Name.Pascal}}Model from table {{.Name.Raw}} by given select query.
//func (mapper *{{.Name.Pascal}}Mapper) FindAll(Select *querybuilder.Select,fields ...string) ([]*{{.Name.Pascal}}Model,error){
//    var result=[]*{{.Name.Pascal}}Model{}
//	rows, err := Select.QueryRows(mapper)
//	if err != nil {
//		return nil, err
//	}
//	defer rows.Close()
//	if len(fields)==0{
//		fields=Default{{.Name.Pascal}}FieldsSelect
//	}	
//	for rows.Next() {
//	    model:=New{{.Name.Pascal}}Model()
//		err = Select.Result().
//			BindFields(model.BuildFields(true,fields...)).
//			ScanFrom(rows)
//		if err != nil {
//			return nil, err
//		}
//		err = model.AfterFind()
//		if err != nil {
//			return nil, err
//		}
//		result = append(result, model)
//	}
//    return result,nil
//}


//{{.Name.Pascal}}  : table {{.Name.Raw}}  mapper instance
var {{.Name.Pascal }} *{{.Name.Pascal }}Mapper

//You  can create transaction with this database.Example:
//func ExampleTx() error {
//	txdb, err := db.NewTxDB({{.Name.Pascal }}Database)
//	if err != nil {
//		panic(err)
//	}
//	{{.Name.Pascal }}Tx := New{{.Name.Pascal }}Mapper(txdb)
//	defer txdb.Rollback()
//  {{.Name.Pascal }}Tx.DoSomething...
//	return txdb.Commit()
//}

// {{.Name.Pascal }}Database database by which settings mapper query data.
var {{.Name.Pascal }}Database db.Database


//New{{.Name.Pascal}}Mapper create new table  {{.Name.Raw}} mapper
func New{{.Name.Pascal}}Mapper(database db.Database) *{{.Name.Pascal}}Mapper {
	var sqltable = db.NewTable(database, {{.Name.Pascal}}TableName)
	sqltable.SetAlias({{.Name.Pascal}}TableAlias)
	return &{{.Name.Pascal}}Mapper{
		ModelMapper: modelmapper.New(sqltable),
	}
}


func init() {
	util.RegisterInitiator({{.Name.Lower}}.ModuleName, "{{.Module}}models", func() {
			{{.Name.Pascal }}Database=database.SQL
			{{.Name.Pascal}} = New{{.Name.Pascal}}Mapper({{.Name.Pascal }}Database)
	})
}